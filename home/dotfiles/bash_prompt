# vim: set filetype=sh :

# Color constants
txtblk='\[\e[0;30m\]' # Black - Regular
txtred='\[\e[0;31m\]' # Red
txtgrn='\[\e[0;32m\]' # Green
txtylw='\[\e[0;33m\]' # Yellow
txtblu='\[\e[0;34m\]' # Blue
txtpur='\[\e[0;35m\]' # Purple
txtcyn='\[\e[0;36m\]' # Cyan
txtwht='\[\e[0;37m\]' # White
bldblk='\[\e[1;30m\]' # Black - Bold
bldred='\[\e[1;31m\]' # Red
bldgrn='\[\e[1;32m\]' # Green
bldylw='\[\e[1;33m\]' # Yellow
bldblu='\[\e[1;34m\]' # Blue
bldpur='\[\e[1;35m\]' # Purple
bldcyn='\[\e[1;36m\]' # Cyan
bldwht='\[\e[1;37m\]' # White
undblk='\[\e[4;30m\]' # Black - Underline
undred='\[\e[4;31m\]' # Red
undgrn='\[\e[4;32m\]' # Green
undylw='\[\e[4;33m\]' # Yellow
undblu='\[\e[4;34m\]' # Blue
undpur='\[\e[4;35m\]' # Purple
undcyn='\[\e[4;36m\]' # Cyan
undwht='\[\e[4;37m\]' # White
bakblk='\[\e[40m\]'   # Black - Background
bakred='\[\e[41m\]'   # Red
bakgrn='\[\e[42m\]'   # Green
bakylw='\[\e[43m\]'   # Yellow
bakblu='\[\e[44m\]'   # Blue
bakpur='\[\e[45m\]'   # Purple
bakcyn='\[\e[46m\]'   # Cyan
bakwht='\[\e[47m\]'   # White
txtrst='\[\e[0m\]'    # Text Reset

case $((RANDOM % 6)) in
  0) ps_gradient=(196 197 198 199 200 165 129 93 57 21);;
  1) ps_gradient=(93 129 165 201 205 204 203 202);;
  2) ps_gradient=(19 20 56 92 128 164);;
  5) ps_gradient=(202 203 204 210 216 222 228 227 226);;
esac

ps_template=(hostname retval numjobs loadavg cwd)

makeps() {
  local ret=$?
  local max_w="`stty size | cut -d ' ' -f 2`"

  [[ -z "$1" ]] && {
    local elem elem_w row p prompt
    local row_w=0
    local row_n=0
    declare -a rows

    for ((p = 0; p < ${#ps_template[@]}; ++p)); do
      elem="`makeps ${ps_template[$p]}`"

      elem_w="`echo -n "$elem" | wc -c`"
      ((row_w += elem_w))
      ((row_w > max_w)) && {
        rows[$row_n]="'$row'"
        row="$elem"
        row_w="$elem_w"
        ((++row_n))
        continue
      }

      row+="$elem"
    done
    (( row_w != 0 )) &&
      rows[$row_n]="'$row'"

    echo "`eval makeps colorize ${rows[@]}`"

    return $ret
  }

  case $1 in
    hostname)
      echo -n "[ ${USER}@${HOSTNAME} ]"
      ;;
    retval)
      echo -n "[ return: $ret ]"
      ;;
    numjobs)
      echo -n "[ jobs: `jobs | wc -l` ]"
      ;;
    loadavg) # TODO: Make this work
      echo -n "[ load avg: `cut -d ' ' -f 2 /proc/loadavg` ]"
      ;;
    cwd)
      local cwd="${PWD/$HOME/\~}"
      ((`echo -n $cwd | wc -c` + 4 > max_w)) &&
        cwd="`basename $cwd`"
      echo -n "[ $cwd ]"
      ;;
    line1)
      echo -n "$(prompt h)$(prompt r)$(prompt j)"
      ;;
    line2)
      echo -n "$(prompt L)$(prompt w)"
      ;;
    $)
      if (( EUID == 0 )); then
        echo -n '# '
      else
        echo -n '$ '
      fi
      echo -n "$txtrst"
      ;;
    colorize)
      local longest=0
      local gstart=0
      local len oifs i c g
      declare -a lines line
      shift
      
      i=0
      while [ "$1" ]; do
        lines[$i]="$1"
        len="`wc -c <<< ${lines[$i]}`"
        ((len > longest)) && longest=$len
        let i++
        shift
      done

      chunk=$((longest / ${#ps_gradient[@]}))
      ((chunk < 1)) && chunk=1

      oifs=$IFS
      IFS='^'
      for ((i = 0; i < ${#lines[@]}; ++i)); do
        line=(`sed -r 's/(.)/\1^/g' <<< ${lines[$i]}`)

        g=$gstart
        for ((c = 0; c < ${#line[@]}; ++c)); do
          ((c % chunk == 0 && g < ${#ps_gradient[@]})) && {
            tput setaf ${ps_gradient[$g]}
            let g++
          }
          echo -n "${line[c]}"
        done

        #let gstart++
        tput setaf ${ps_gradient[$gstart]}
        echo
      done
      IFS=$oifs
      ;;
    *)
      echo -n "[ makeps: can't parse $1 ]"
      ;;
  esac

  return $ret
}

# Draw the prompt
export PS1="\`makeps\`\n\$$txtrst "
